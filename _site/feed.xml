<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>haiqus | elegant code</title>
    <description>touch sixty-four keys-- transistors turn on, off. thoughts become electric. Personal weblog of Jared Davis</description>
    <link>http://haiqus.com/</link>
    <atom:link href="http://haiqus.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 08 Sep 2015 19:02:04 -0500</pubDate>
    <lastBuildDate>Tue, 08 Sep 2015 19:02:04 -0500</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>introduction to `ngrep`</title>
        <description>&lt;p&gt;The *nix utility program &lt;code&gt;ngrep&lt;/code&gt; allows you to search and filter network packets. Much like the well-known &lt;code&gt;grep&lt;/code&gt; tool enables users to search text located in files and &lt;code&gt;stdin&lt;/code&gt;/&lt;code&gt;stdout&lt;/code&gt;, &lt;code&gt;ngrep&lt;/code&gt; performs similar tasks against the operating system’s networking interface. In the words of its manpages, &lt;code&gt;ngrep&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;currently recognizes TCP, UDP and ICMP across Ethernet, PPP, SLIP, FDD and null interfaces, and understands bpf filter logic in the same fashion as more common packet sniffing tools, such as tcpdump(8) and snoop(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simply feed &lt;code&gt;ngrep&lt;/code&gt; a regular expression, and optionally a protocol, interface, and bpf filter, and you can print live networking packets to &lt;code&gt;stdout&lt;/code&gt;, redirect (&lt;code&gt;&amp;gt;&lt;/code&gt;) the contents to a file, or pipe (&lt;code&gt;|&lt;/code&gt;) to another utility. Here’s some examples:&lt;/p&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ngrep&lt;/code&gt; is intended to be used alongside your standard *nix command-line tooling. Thus, most package repositories are sufficiently up-to-date.&lt;/p&gt;

&lt;p&gt;On MacOS, use homebrew:
- &lt;code&gt;brew install ngrep&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;On Debian based systems (eg, Ubuntu), use aptitude:
- &lt;code&gt;apt-get install ngrep&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;On CentOS, use yum:
- &lt;code&gt;yum install ngrep&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;basic-usage&quot;&gt;Basic Usage&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ngrep -q &#39;HTTP&#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This command will query all interfaces and protocols for a string match of &lt;code&gt;&#39;HTTP&#39;&lt;/code&gt;. The &lt;code&gt;-q&lt;/code&gt; flag will ‘quiet’ the output by printing only packet headers and relevant payloads. Most of the time, it is best to use ‘quiet’ output; otherwise, you might as well use &lt;code&gt;tcpdump&lt;/code&gt; to capture everything. I will use &lt;code&gt;-q&lt;/code&gt; in all the examples below so nobody cuts-and-pastes from this article and gets flooded with too much data.&lt;/p&gt;

&lt;h2 id=&quot;adding-timestamps&quot;&gt;Adding Timestamps&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ngrep -qt &#39;HTTP&#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Use the &lt;code&gt;t&lt;/code&gt; flag to print a timestamp along with the matched information. Use &lt;code&gt;T&lt;/code&gt; to print the time elapsed between successive matches.&lt;/p&gt;

&lt;h2 id=&quot;reading-from-pcap&quot;&gt;Reading from pcap&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ngrep -I network_capture.pcap -qt &#39;HTTP&#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you have a network capture file in &lt;code&gt;.pcap&lt;/code&gt; format, use &lt;code&gt;-I $FILE&lt;/code&gt; to filter the capture instead of a network interface. This can be handy, for example, if you have a record of a networking event and you need to do a quick analysis without all the bells and whistles of &lt;code&gt;wireshark&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;writing-to-pcap&quot;&gt;Writing to pcap&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ngrep -O network_capture.pcap -q &#39;HTTP&#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Reverse of the above command, using only the &lt;code&gt;-O&lt;/code&gt; flag will filter against a network interface and copy the matched packets into a capture file in &lt;code&gt;.pcap&lt;/code&gt; format.&lt;/p&gt;

&lt;h2 id=&quot;reading-with-byline&quot;&gt;Reading with byline&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ngrep -q -Wbyline &#39;HTTP&#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Linefeeds are printed as linefeeds, making the output pretty and more legible.&lt;/p&gt;

&lt;h2 id=&quot;common-bpf-filters&quot;&gt;Common bpf filters&lt;/h2&gt;
&lt;p&gt;A &lt;a href=&quot;http://biot.com/capstats/bpf.html&quot;&gt;bpf&lt;/a&gt; specifies a rich syntax for filtering network packets based on information such as IP address, IP protocol, and port number.&lt;/p&gt;

&lt;h3 id=&quot;ip-address&quot;&gt;IP address&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ngrep -q &#39;HTTP&#39; &#39;host 192.168&#39;&lt;/code&gt; matches all headers containing the string &lt;code&gt;&#39;HTTP&#39;&lt;/code&gt; sent to or from the ip address starting with &lt;code&gt;192.168&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ngrep -q &#39;HTTP&#39; &#39;dst host 192.168&#39;&lt;/code&gt; will do as above, but instead match a destination host&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ngrep -q &#39;HTTP&#39; &#39;src host 192.168&#39;&lt;/code&gt; will do as above, but instead match a source host&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ip-protocol&quot;&gt;IP protocol&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ngrep -q &#39;HTTP&#39; &#39;tcp&#39;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ngrep -q &#39;HTTP&#39; &#39;udp&#39;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ngrep -q &#39;HTTP&#39; &#39;icmp&#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;port-number&quot;&gt;port number&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ngrep -q &#39;HTTP&#39; &#39;port 80&#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pretty cool! There are many primitives available, but I only really need to use these three. You can combine primitives using boolean connectives &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;not&lt;/code&gt; to really specify what your grepping.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ngrep&lt;/code&gt; is a pretty handy utility allowing search on network interfaces or captures. Anyone familiar with &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;tcpdump&lt;/code&gt;, or &lt;code&gt;wireshark&lt;/code&gt; will find it very valuable for quick network analyses.&lt;/p&gt;
</description>
        <pubDate>Wed, 20 Aug 2014 19:00:00 -0500</pubDate>
        <link>http://haiqus.com/1up/2014/08/20/introduction-to-ngrep/</link>
        <guid isPermaLink="true">http://haiqus.com/1up/2014/08/20/introduction-to-ngrep/</guid>
        
        
        <category>1up</category>
        
      </item>
    
      <item>
        <title>Balance with Scala</title>
        <description>&lt;p&gt;Scala is a pleasant and powerful language. Here’s a simple exercise demonstrating functional programming by checking whether a string has balanced parentheses or no.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def balanced(chars: List[Char]): Boolean = {
  def innerBalance(thisChar: Char, rest: List[Char], center: Int): Int = {
    def shift(thisChar: String, center: Int): Int = {
      if      (thisChar == &quot;(&quot;) center &amp;lt;&amp;lt; 1
      else if (thisChar == &quot;)&quot;) center &amp;gt;&amp;gt; 1
      else center
    }
    if (rest.isEmpty) shift(thisChar.toString, center)
    else innerBalance(rest.head, rest.tail, shift(thisChar.toString, center))
  }
  innerBalance(chars.head, chars.tail, 1) == 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;very pleasant indeed!&lt;/p&gt;
</description>
        <pubDate>Thu, 08 May 2014 00:00:00 -0500</pubDate>
        <link>http://haiqus.com/scala/functional%20programming/2014/05/08/balance-with-scala/</link>
        <guid isPermaLink="true">http://haiqus.com/scala/functional%20programming/2014/05/08/balance-with-scala/</guid>
        
        
        <category>scala</category>
        
        <category>functional programming</category>
        
      </item>
    
      <item>
        <title>Grabbing Timestamp Data from Logs</title>
        <description>&lt;p&gt;Background: Much software involves running multiple processes. Often, this means a user session in web programming; at Ifbyphone, this means a particular phonecall.&lt;/p&gt;

&lt;p&gt;Assignment: Given a log file, measure the time differences (deltas) between each event for a specific phonecall.&lt;/p&gt;

&lt;p&gt;Usecase: You know a phonecall of this type has a particular flow. This specific phonecall has experienced an abnormal flow, and you need to see where it has deviated from the norm.&lt;/p&gt;

&lt;p&gt;Tools: Basic Unix server environment.&lt;/p&gt;

&lt;p&gt;Sample Logfile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DEBUG agi 2013-10-04 03:05:00.261 [unique-id] . . .
INFO http 2013-10-04 03:05:00.274 [unique-id] . . .
INFO http 2013-10-04 03:05:00.287 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:00.303 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:03.193 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:03.200 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:03.210 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:03.219 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:07.667 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:07.905 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:08.007 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:08.022 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:08.657 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:08.657 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:08.658 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:08.658 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:08.659 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:08.659 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:08.992 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:08.992 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:08.993 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:08.993 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:20.612 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:20.613 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:20.613 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:20.615 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:21.328 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:21.329 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:21.329 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:21.330 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:33.292 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:33.292 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:33.292 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:33.294 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:36.979 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:36.980 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:36.980 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:36.980 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:37.613 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:37.614 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:37.614 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:37.615 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:42.172 [unique-id] . . .
DEBUG input 2013-10-04 03:05:42.173 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:42.173 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:42.425 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:42.425 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:42.425 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:42.425 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:42.677 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:42.677 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:42.677 [unique-id] . . .
DEBUG agi 2013-10-04 03:05:42.679 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:28.707 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:28.708 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:28.708 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:28.709 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:29.343 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:29.343 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:29.344 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:29.344 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:32.932 [unique-id] . . .
DEBUG input 2013-10-04 03:06:32.932 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:32.933 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:33.184 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:33.184 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:33.184 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:33.185 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:33.436 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:33.436 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:33.437 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:33.438 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:50.932 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:50.933 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:50.933 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:50.934 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:51.567 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:51.567 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:51.567 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:51.568 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:55.452 [unique-id] . . .
DEBUG input 2013-10-04 03:06:55.452 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:55.452 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:55.704 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:55.704 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:55.705 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:55.705 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:55.956 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:55.957 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:55.957 [unique-id] . . .
DEBUG agi 2013-10-04 03:06:55.958 [unique-id] . . .
DEBUG agi 2013-10-04 03:07:10.268 [unique-id] . . .
DEBUG agi 2013-10-04 03:07:10.268 [unique-id] . . .
DEBUG agi 2013-10-04 03:07:10.269 [unique-id] . . .
DEBUG agi 2013-10-04 03:07:10.270 [unique-id] . . .
DEBUG agi 2013-10-04 03:07:10.271 [unique-id] . . .
INFO http 2013-10-04 03:07:10.272 [unique-id] . . .
INFO http 2013-10-04 03:07:10.277 [unique-id] . . .
INFO http 2013-10-04 03:07:10.306 [unique-id] . . .
DEBUG agi 2013-10-04 03:07:10.306 [unique-id] . . .
DEBUG agi 2013-10-04 03:07:10.307 [unique-id] . . .
DEBUG agi 2013-10-04 03:07:10.307 [unique-id] . . .
DEBUG agi 2013-10-04 03:07:10.308 [unique-id] . . .
INFO ahn 2013-10-04 03:07:10.308 [unique-id] . . .
DEBUG agi 2013-10-04 03:07:10.309 [unique-id] . . .
DEBUG agi 2013-10-04 03:07:10.310 [unique-id] . . .
INFO ahn 2013-10-04 03:07:10.311 [unique-id] . . .
INFO agi 2013-10-04 03:07:10.312 [unique-id] . . .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The log entry starts with a basic log-level notice, followed by the service, and then date and time. Between the brackets, you have a unique id associated with the phonecall. After the unique id, there’s the contents of the log message.&lt;/p&gt;

&lt;p&gt;Solution:&lt;/p&gt;

&lt;p&gt;Grab the appropriate excerpt from the main logfile. Keep a copy of this excerpt for parsing.
    nice grep ‘unique-id’ main.log &amp;gt; /tmp/unique.log
    logfile=/tmp/unique.log
    timestamps=$logfile.timestamps&lt;/p&gt;

&lt;p&gt;For convenience, extract &lt;em&gt;only the timestamps&lt;/em&gt;. These we’ll save for parsing.
    logfile=/tmp/unique.log
    timestamps=$logfile.timestamps
    cat $logfile | awk ‘{print $4}’ &amp;gt; $timestamps&lt;/p&gt;

&lt;p&gt;Now the fun part! We’ll use sed to chop each timestamp into hour, minute, second, and millisecond pieces, then pipe those pieces to awk to do basic arithmetic.
    cat $timestamps | sed ‘s/[:.]/ /g’ | awk ‘{ time = ($1&lt;em&gt;3600 + $2&lt;/em&gt;60 + $3)*1000 + $4 }; NR==1{ prev = time}; {print time - prev }; {prev = time}’&lt;/p&gt;

&lt;p&gt;If you’re not familiar with awk, I’ll break this down a bit more. It’s not advanced, but I can understand how the syntax can be challenging if you’re unfamiliar.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The first argument ($1) corresponds to hours, the second to minutes ($2), the third ($3) to seconds, and the fourth ($4) to milliseconds. We convert the entire timestamp to milliseconds with &lt;code&gt;($1*3600 + $2*60 + $3)*1000 + $4&lt;/code&gt; and keep this conversion as the variable &lt;code&gt;time&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;If we’re on the first line, &lt;code&gt;NR==1&lt;/code&gt;, then we also assign the previous time to the current time &lt;code&gt;prev = time&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;We’ll print the difference between the previous and the current time, &lt;code&gt; {print time - prev }&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Finally, set the previous time to the current time. This will be done for &lt;em&gt;all&lt;/em&gt; timestamps, notably &lt;em&gt;after&lt;/em&gt; calculating the delta.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here’s the results, further parsed into a comma delineated list:&lt;/p&gt;

&lt;p&gt;0, 13, 13, 16, 2890, 7, 10, 9, 4448, 238, 102, 15, 635, 0, 1, 0, 1, 0, 333, 0, 1, 0, 11619, 1, 0, 2, 713, 1, 0, 1, 11962, 0, 0, 2, 3685, 1, 0, 0, 633, 1, 0, 1, 4557, 1, 0, 252, 0, 0, 0, 252, 0, 0, 2, 46028, 1, 0, 1, 634, 0, 1, 0, 3588, 0, 1, 251, 0, 0, 1, 251, 0, 1, 1, 17494, 1, 0, 1, 633, 0, 0, 1, 3884, 0, 0, 252, 0, 1, 0, 251, 1, 0, 1, 14310, 0, 1, 1, 1, 1, 5, 29, 0, 1, 0, 1, 0, 1, 1, 1, 1&lt;/p&gt;

&lt;p&gt;Which we can easily load into R for a quick and dirty visualization:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data&amp;lt;-c(0, 13, 13, 16, 2890, 7, 10, 9, 4448, 238, 102, 15, 635, 0, 1, 0, 1, 0, 333, 0, 1, 0, 11619, 1, 0, 2, 713, 1, 0, 1, 11962, 0, 0, 2, 3685, 1, 0, 0, 633, 1, 0, 1, 4557, 1, 0, 252, 0, 0, 0, 252, 0, 0, 2, 46028, 1, 0, 1, 634, 0, 1, 0, 3588, 0, 1, 251, 0, 0, 1, 251, 0, 1, 1, 17494, 1, 0, 1, 633, 0, 0, 1, 3884, 0, 0, 252, 0, 1, 0, 251, 1, 0, 1, 14310, 0, 1, 1, 1, 1, 5, 29, 0, 1, 0, 1, 0, 1, 1, 1, 1)
barplot(x, main=&quot;Event Deltas (ms) for unique-id&quot;, xlab=&quot;Events (in series)&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://haiqus.com/rplot.png&quot; alt=&quot;Event Deltas (ms) for unique-id&quot; title=&quot;Event Deltas (ms) for unique-id&quot; style=&quot;max-width:100%;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 04 Oct 2013 00:00:00 -0500</pubDate>
        <link>http://haiqus.com/unix/2013/10/04/grabbing-timestamp-data-from-logs/</link>
        <guid isPermaLink="true">http://haiqus.com/unix/2013/10/04/grabbing-timestamp-data-from-logs/</guid>
        
        
        <category>unix</category>
        
      </item>
    
      <item>
        <title>What is a Ruby Hash?</title>
        <description>&lt;p&gt;The only answer that matters is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;               static VALUE
rb_hash_s_create(int argc, VALUE *argv, VALUE klass)
{
    VALUE hash, tmp;
    int i;

    if (argc == 1) {
        tmp = rb_hash_s_try_convert(Qnil, argv[0]);
        if (!NIL_P(tmp)) {
            hash = hash_alloc(klass);
            if (RHASH(tmp)-&amp;gt;ntbl) {
                RHASH(hash)-&amp;gt;ntbl = st_copy(RHASH(tmp)-&amp;gt;ntbl);
            }
            return hash;
        }

        tmp = rb_check_array_type(argv[0]);
        if (!NIL_P(tmp)) {
            long i;

            hash = hash_alloc(klass);
            for (i = 0; i &amp;lt; RARRAY_LEN(tmp); ++i) {
                VALUE e = RARRAY_AREF(tmp, i);
                VALUE v = rb_check_array_type(e);
                VALUE key, val = Qnil;

                if (NIL_P(v)) {
#if 0 /* refix in the next release */
                    rb_raise(rb_eArgError, &quot;wrong element type %s at %ld (expected array)&quot;,
                             rb_builtin_class_name(e), i);

#else
                    rb_warn(&quot;wrong element type %s at %ld (expected array)&quot;,
                            rb_builtin_class_name(e), i);
                    rb_warn(&quot;ignoring wrong elements is deprecated, remove them explicitly&quot;);
                    rb_warn(&quot;this causes ArgumentError in the next release&quot;);
                    continue;
#endif
                }
                switch (RARRAY_LEN(v)) {
                  default:
                    rb_raise(rb_eArgError, &quot;invalid number of elements (%ld for 1..2)&quot;,
                             RARRAY_LEN(v));
                  case 2:
                    val = RARRAY_AREF(v, 1);
                  case 1:
                    key = RARRAY_AREF(v, 0);
                    rb_hash_aset(hash, key, val);
                }
            }
            return hash;
        }
    }
    if (argc % 2 != 0) {
        rb_raise(rb_eArgError, &quot;odd number of arguments for Hash&quot;);
    }

    hash = hash_alloc(klass);
    for (i=0; i&amp;lt;argc; i+=2) {
        rb_hash_aset(hash, argv[i], argv[i + 1]);
    }

    return hash;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Read more about it &lt;a href=&quot;https://github.com/ruby/ruby/blob/trunk/hash.c&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Aug 2013 00:00:00 -0500</pubDate>
        <link>http://haiqus.com/ruby/2013/08/19/what-is-a-ruby-hash/</link>
        <guid isPermaLink="true">http://haiqus.com/ruby/2013/08/19/what-is-a-ruby-hash/</guid>
        
        
        <category>ruby</category>
        
      </item>
    
      <item>
        <title>How does curl post data?</title>
        <description>&lt;p&gt;&lt;code&gt;curl&lt;/code&gt; is the Unix library for sending and receiving data from the internet (I’m sure it does much more than that, but I’m not equipped to talk about it!). With &lt;code&gt;curl&lt;/code&gt;, you can post data with the &lt;code&gt;-d&lt;/code&gt; flag. But what does that do? Disclaimer: This is more of a demonstration than a full tutorial.&lt;/p&gt;

&lt;p&gt;Let’s say we’re issuing a query to ElasticSearch, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -XGET http://localhost:9200/articles/_search -d &#39;{&quot;query&quot;:{&quot;query_string&quot;:{&quot;query&quot;:&quot;cat&quot;}}}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can examine how curl is interacting with the specified url by appending the above command with a trace, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; --trace-ascii /dev/stdout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://superuser.com/questions/291424/how-do-you-display-post-data-with-curl&quot;&gt;I learned this trick here&lt;/a&gt;. The output from this command would then be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;== Info: About to connect() to localhost port 9200 (#0)
== Info:   Trying ::1...
== Info: Connection refused
== Info:   Trying 127.0.0.1...
== Info: connected
== Info: Connected to localhost (127.0.0.1) port 9200 (#0)
=&amp;gt; Send header, 230 bytes (0xe6)
0000: GET /articles/_search HTTP/1.1
0020: User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0
0060:  OpenSSL/0.9.8r zlib/1.2.5
007c: Host: localhost:9200
0092: Accept: */*
009f: Content-Length: 42
00b3: Content-Type: application/x-www-form-urlencoded
00e4:
=&amp;gt; Send data, 42 bytes (0x2a)
0000: {&quot;query&quot;:{&quot;query_string&quot;:{&quot;query&quot;:&quot;cat&quot;}}}
== Info: upload completely sent off: 42 out of 42 bytes
&amp;lt;= Recv header, 17 bytes (0x11)
0000: HTTP/1.1 200 OK
&amp;lt;= Recv header, 47 bytes (0x2f)
0000: Content-Type: application/json; charset=UTF-8
&amp;lt;= Recv header, 21 bytes (0x15)
0000: Content-Length: 122
&amp;lt;= Recv header, 2 bytes (0x2)
0000:
&amp;lt;= Recv data, 122 bytes (0x7a)
0000: {&quot;took&quot;:0,&quot;timed_out&quot;:false,&quot;_shards&quot;:{&quot;total&quot;:5,&quot;successful&quot;:5,
0040: &quot;failed&quot;:0},&quot;hits&quot;:{&quot;total&quot;:0,&quot;max_score&quot;:null,&quot;hits&quot;:[]}}
== Info: Connection #0 to host localhost left intact
{&quot;took&quot;:0,&quot;timed_out&quot;:false,&quot;_shards&quot;:{&quot;total&quot;:5,&quot;successful&quot;:5,&quot;failed&quot;:0},&quot;hits&quot;:{&quot;total&quot;:0,&quot;max_score&quot;:null,&quot;hits&quot;:[]}}
== Info: Closing connection #0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We see the communication between our machine via &lt;code&gt;curl&lt;/code&gt; and the ElasticSearch server follow these steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;curl&lt;/code&gt; sends a header to the specified uri to open the connection. ElasticSearch accepts this header and opens up the connection.&lt;/li&gt;
  &lt;li&gt;The data packet is sent through the open connection.&lt;/li&gt;
  &lt;li&gt;ElasticSearch sends its response header with a &lt;code&gt;HTTP/1.1 200&lt;/code&gt; success status code.&lt;/li&gt;
  &lt;li&gt;ElasticSearch sends the data, which our machine accepts and closes the connection.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That pattern illustrates what happens during a typical data post via curl, or any other http client for that matter.&lt;/p&gt;

&lt;p&gt;Now for fun, let’s contrast this correct usage of the ElasticSearch api with something less useful&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -X GET http://localhost:9200/articles/_search?%7B%22query%22%3A%7B%22query_string%22%3A%7B%22query%22%3A%22cat%22%7D%7D%7D  --trace-ascii /dev/stdout
== Info: About to connect() to localhost port 9200 (#0)
== Info:   Trying ::1...
== Info: Connection refused
== Info:   Trying 127.0.0.1...
== Info: connected
== Info: Connected to localhost (127.0.0.1) port 9200 (#0)
=&amp;gt; Send header, 238 bytes (0xee)
0000: GET /articles/_search?%7B%22query%22%3A%7B%22query_string%22%3A%
0040: 7B%22query%22%3A%22cat%22%7D%7D%7D HTTP/1.1
006d: User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0
00ad:  OpenSSL/0.9.8r zlib/1.2.5
00c9: Host: localhost:9200
00df: Accept: */*
00ec:
&amp;lt;= Recv header, 17 bytes (0x11)
0000: HTTP/1.1 200 OK
&amp;lt;= Recv header, 47 bytes (0x2f)
0000: Content-Type: application/json; charset=UTF-8
&amp;lt;= Recv header, 23 bytes (0x17)
0000: Content-Length: 35894
&amp;lt;= Recv header, 2 bytes (0x2)
0000:
&amp;lt;= Recv data, 16295 bytes (0x3fa7)
0000: {&quot;took&quot;:39,&quot;timed_out&quot;:false,&quot;_shards&quot;:{&quot;total&quot;:5,&quot;successful&quot;:5
0040: ,&quot;failed&quot;:0},&quot;hits&quot;:{&quot;total&quot;:13,&quot;max_score&quot;:1.0,&quot;hits&quot;:[{&quot;_index
0080: &quot;:&quot;articles&quot;,&quot;_type&quot;:&quot;article&quot;,&quot;_id&quot;:&quot;4&quot;,&quot;_score&quot;:1.0, &quot;_source&quot;
00c0:  : {&quot;type&quot;:&quot;article&quot;,&quot;id&quot;:4,&quot;summary&quot;:&quot;&amp;lt;p&amp;gt;With grep, you can not
0100:  only return the matching line for your string or regex, but als
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and a few hundred lines later&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;== Info: Closing connection #0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What happened? We didn’t &lt;em&gt;send&lt;/em&gt; any data, we just requested a uri (namely &lt;code&gt;http://localhost:9200/articles/_search&lt;/code&gt;) with a uri encoded string concatenated at the end. That’s &lt;em&gt;not&lt;/em&gt; a proper POST and &lt;em&gt;not&lt;/em&gt; how the ElasticSearch api handles a query. Hence, the server defaulted by querying all, returning every document (with a default limit of ten documents) in the response body. We sent an ok get, but the params weren’t something the server could work with; the server wanted actual POST data as in the first example above.&lt;/p&gt;
</description>
        <pubDate>Thu, 15 Aug 2013 00:00:00 -0500</pubDate>
        <link>http://haiqus.com/curl/http/2013/08/15/how-does-curl-post-data/</link>
        <guid isPermaLink="true">http://haiqus.com/curl/http/2013/08/15/how-does-curl-post-data/</guid>
        
        
        <category>curl</category>
        
        <category>http</category>
        
      </item>
    
      <item>
        <title>Using the Pry Repl</title>
        <description>&lt;p&gt;Many Ruby programmers are introduced to the language via the built-in “interactive Ruby” environment, or irb. The irb is a read, evaluate, print loop (aka REPL) which allows the programmer to modify her code dynamically during development, seeing results in real time. But irb is not the only Ruby REPL out there; pry in particular has become my favorite.&lt;/p&gt;

&lt;p&gt;Install pry as you would any other gem, &lt;code&gt;gem install pry&lt;/code&gt;, and place any customizations in &lt;code&gt;~/.pryrc&lt;/code&gt; (global) or just &lt;code&gt;.pryrc&lt;/code&gt; (current directory only) as a Ruby script. From there, you can use pry just like irb, or you could do something a bit more interesting.&lt;/p&gt;

&lt;p&gt;Here’s the sample code I’m working with, my hobby-horse, an implementation of the Fibonacci series.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Fib

  attr_accessor :past, :prev, :current

  def initialize
    @past    = 0
    @prev    = 1
    @current = 1

    @cache = [@past, @prev, @current]
  end

  def next
    @past    = @prev
    @prev    = @current
    @current = @past + @prev
    @cache  &amp;lt;&amp;lt; @current
    return self
  end

  def size
    @cache.size
  end

  def find(n)
    (n - size + 1).times{ self.next } unless @cache[n]
    @cache[n]
  end

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I’m pasting this directly into pry to evaluate the algorithm.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; class Fib
 |
 |   attr_accessor :past, :prev, :current
 |
 |   def initialize
 |     @past    = 0
 |     @prev    = 1
 |     @current = 1
 |
 |     @cache = [@past, @prev, @current]
 |   end
 |
 |   def next
 |     @past    = @prev
 |     @prev    = @current
 |     @current = @past + @prev
 |     @cache  &amp;lt;&amp;lt; @current
 |     return self
 |   end
 |
 |   def size
 |     @cache.size
 |   end
 |
 |   def find(n)
 |     (n - size + 1).times{ self.next } unless @cache[n]
 |     @cache[n]
 |   end
 |
 | end
=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool. Everything is familiar so far, except you’ll notice your console has some pretty colors! Grab the tenth Fibonacci for illustration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; f = Fib.new
=&amp;gt; #&amp;lt;Fib:0x007fa35c4c58e0 @cache=[0, 1, 1], @current=1, @past=0, @prev=1&amp;gt;
&amp;gt;&amp;gt; f.find(10)
=&amp;gt; 55
&amp;gt;&amp;gt; f
=&amp;gt; #&amp;lt;Fib:0x007fa35c4c58e0
 @cache=[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55],
 @current=55,
 @past=21,
 @prev=34&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, all familiar output, similar to irb. Now let’s do something cool:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; cd f
&amp;gt;&amp;gt; ls
Fib#methods:
  a   b   c   current   d   find  next  past=  prev=
  a=  b=  c=  current=  d=  fold  past  prev   size
self.methods: __pry__
instance variables: @cache  @current  @past  @prev
locals: _  __  _dir_  _ex_  _file_  _in_  _out_  _pry_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We just used the Unix &lt;code&gt;cd&lt;/code&gt; command to “navigate” “inside” the object &lt;code&gt;f&lt;/code&gt;, then used &lt;code&gt;ls&lt;/code&gt; to display the object’s class level methods, instance variables, as well as the REPL’s own local variables.&lt;/p&gt;

&lt;p&gt;We can go deeper, say, into the object’s own instance variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; cd @cache
&amp;gt;&amp;gt; ls
Enumerable#methods:
  all?            each_entry        find_all  max      minmax_by     sort_by
  any?            each_slice        flat_map  max_by   none?         to_set
  chunk           each_with_index   grep      member?  one?
  collect_concat  each_with_object  group_by  min      partition
Enumerable#methods:
  all?            each_entry        find_all  max      minmax_by     sort_by
  any?            each_slice        flat_map  max_by   none?         to_set
  chunk           each_with_index   grep      member?  one?
  collect_concat  each_with_object  group_by  min      partition
  detect          entries           inject    min_by   reduce
  each_cons       find              lazy      minmax   slice_before
Array#methods:
  &amp;amp;            count       include?            reject!               slice!
  *            cycle       index               repeated_combination  sort
  +            delete      insert              repeated_permutation  sort!
  -            delete_at   inspect             replace               sort_by!
  &amp;lt;&amp;lt;           delete_if   join                reverse               take
  &amp;lt;=&amp;gt;          drop        keep_if             reverse!              take_while
  ==           drop_while  last                reverse_each          to_a
  []           each        length              rindex                to_ary
  []=          each_index  map                 rotate                to_s
  assoc        empty?      map!                rotate!               transpose
  at           eql?        pack                sample                uniq
  bsearch      fetch       permutation         select                uniq!
  clear        fill        pop                 select!               unshift
  collect      find_index  pretty_print        shelljoin             values_at
  collect!     first       pretty_print_cycle  shift                 zip
  combination  flatten     product             shuffle               |
  compact      flatten!    push                shuffle!
  compact!     frozen?     rassoc              size
  concat       hash        reject              slice
self.methods: __pry__
locals: _  __  _dir_  _ex_  _file_  _in_  _out_  _pry_
&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A lightbulb ought to shine bright here. You’ve likely come across a situation where you needed to know which methods were available after calling a some other method. Now it’s easy as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; cd f.size
&amp;gt;&amp;gt; ls
Comparable#methods: between?
Numeric#methods:
  +@      conj       imaginary     pretty_print_cycle  rectangular
  abs2    conjugate  nonzero?      quo                 remainder
  angle   eql?       phase         real                singleton_method_added
  arg     i          polar         real?               step
  coerce  imag       pretty_print  rect                to_c
Integer#methods:
  ceil         downto  gcdlcm    next       pred         times  to_int    upto
  chr          floor   integer?  numerator  rationalize  to_bn  to_r
  denominator  gcd     lcm       ord        round        to_i   truncate
Fixnum#methods:
  %  **  -@  &amp;lt;&amp;lt;   ==   &amp;gt;=  ^        div     fdiv       modulo  succ  zero?
  &amp;amp;  +   /   &amp;lt;=   ===  &amp;gt;&amp;gt;  __pry__  divmod  inspect    odd?    to_f  |
  *  -   &amp;lt;   &amp;lt;=&amp;gt;  &amp;gt;    []  abs      even?   magnitude  size    to_s  ~
locals: _  __  _dir_  _ex_  _file_  _in_  _out_  _pry_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Above we called &lt;code&gt;Fib#size&lt;/code&gt; to see how many numbers are in the object’s cache. Since the method returns an integer, the methods that we can chain off &lt;code&gt;Fib#size&lt;/code&gt; are only those that pertain to &lt;code&gt;Integer&lt;/code&gt;. Simple concept, but profound discovery via the pry REPL!&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Aug 2013 00:00:00 -0500</pubDate>
        <link>http://haiqus.com/algorithms/tools/2013/08/12/using-the-pry-repl/</link>
        <guid isPermaLink="true">http://haiqus.com/algorithms/tools/2013/08/12/using-the-pry-repl/</guid>
        
        
        <category>algorithms</category>
        
        <category>tools</category>
        
      </item>
    
      <item>
        <title>Simple and Lovely</title>
        <description>&lt;p&gt;Simple is beautiful, and because simple atomic, code, when composed with other simple, atomic chunks of code, has the potential to express quite a bit of complexity.&lt;/p&gt;

&lt;p&gt;Here is a perennial favorite. The rules are expressed as comments in the code itself&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fizzbuzz = lambda do |n|
  if n % 5 == 0 &amp;amp;&amp;amp; n % 3 == 0
    # Rule 3 - if n is divisible by both 3 and 5, say &quot;fizzbuzz&quot;
    n = :fizzbuzz
  elsif n % 5 == 0
    # Rule 2 - if n is divisible by 5, say &quot;buzz&quot;
    n = :buzz
  elsif n % 3 == 0
    # Rule 1 - if n is divisible by 3, say &quot;fizz&quot;
    n = :fizz
  else
    # Rule 4 - otherwise, say n
    n = n
  end
  return n
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let’s say we want to transform a range or an array of numbers into its fizzy-buzzy equivalent.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fizzbuzz_sequence = lambda do |seq|
  seq.map{|n| fizzbuzz.call n }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next example is written in JavaScript,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function divide(array, k) {
  // divide an array at position k from the tail
  if(array === undefined || array === null){ return null }

  var head = array, // we want to preserve the original array
      tail = [],
      end;

  for(var i=0; i&amp;lt;k; i++){
    end = head.pop();
    if(end !== undefined){ tail.unshift(end) }
  }
  return {&quot;head&quot;:head, &quot;tail&quot;:tail};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One could just as easily go from the other direction (I just thought cutting from the tail was more interesting). Just swap “head” with “tail” to get the same results.&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Jul 2013 00:00:00 -0500</pubDate>
        <link>http://haiqus.com/algorithms/2013/07/13/simple-and-lovely/</link>
        <guid isPermaLink="true">http://haiqus.com/algorithms/2013/07/13/simple-and-lovely/</guid>
        
        
        <category>algorithms</category>
        
      </item>
    
      <item>
        <title>Fun with Public Data</title>
        <description>&lt;p&gt;Similar datasets can be found at &lt;a href=&quot;https://data.cityofchicago.org/&quot;&gt;data.cityofchicago.org&lt;/a&gt;. In this post, I’ll try to keep the prose at a minimum and let the code do the talking.&lt;/p&gt;

&lt;p&gt;First, let’s set some objectives: (a) acquire the data, (b) reformat the data for passing around our code, (c) store the data for querying, (d) run some queries and present the results. To prepare, let’s grab some tools (in Ruby)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# objective (a)
require &#39;httparty&#39;
# objective (b)
require &#39;json&#39;
# objective (c) and (d)
require &#39;sqlite3&#39;
require &#39;sequel&#39;
# objective (d)
require &#39;gnuplot&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;objective-a&quot;&gt;Objective (a)&lt;/h2&gt;

&lt;p&gt;HTTParty will do the acquisition for us, which is pretty easy given Chicago’s data API:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;full_data = HTTParty.get(&#39;https://data.cityofchicago.org/api/views/mq3i-nnqe/rows.json&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;objective-b&quot;&gt;Objective (b)&lt;/h2&gt;

&lt;p&gt;I chose to grab the json document; the format of the document makes my job harder, but I’m more familiar with parsing json objects than other (potentially wackily formatted) filetypes.&lt;/p&gt;

&lt;h2 id=&quot;objective-c&quot;&gt;Objective (c)&lt;/h2&gt;

&lt;p&gt;Now, we set up the database. The following will create an in-memory database and some tables.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CTA_BUSES = Sequel.sqlite

CTA_BUSES.create_table :passenger_data do
  # auto increment id
  foriegn_key       :stop_id
  Decimal           :alightings
  Decimal           :boardings
end

CTA_BUSES.create_table :stop_locations do
  # auto increment id
  foriegn_key       :stop_id
  Decimal           :loc_lat
  Decimal           :loc_long
  String            :cross_street
  String            :on_street
end

CTA_BUSES.create_table :stops do
  primary_key       :id
end

CTA_BUSES.create_table :route_stops do
  # auto increment id
  foriegn_key       :stop_id
  String            :route_name
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I don’t promise that these schemata are good architecture; it’s just what I settled on to do the best analysis I could. I’d love to see better :)&lt;/p&gt;

&lt;p&gt;After cleaning the data for insertion, we simply use Sequel’s very straightforward syntax.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stops.each          { |data| CTA_BUSES[:stops].insert(data) }
stop_locations.each { |data| CTA_BUSES[:stop_locations].insert(data) }
route_stops.each    { |data| CTA_BUSES[:route_stops].insert(data) }
passenger_data.each { |data| CTA_BUSES[:passenger_data].insert(data) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code inside the loop - &lt;code&gt;CTA_BUSES[:stops].insert(data)&lt;/code&gt; - is sugar for &lt;code&gt;INSERT INTO `stops` (keys) VALUES (values)&lt;/code&gt; where &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; are the keys and values of the hash &lt;code&gt;data&lt;/code&gt;. There’s probably a better way to do a bulk insert that doesn’t rely on a loop… just don’t know Sequel’s syntax for this case and didn’t bother looking.&lt;/p&gt;

&lt;h2 id=&quot;objective-d&quot;&gt;Objective (d)&lt;/h2&gt;

&lt;p&gt;Now we can query! I just wrote raw SQL since I’m interested in learning better query techniques without the help of an ORM.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;full_query =&amp;lt;&amp;lt;SQL
  select rs.route_name, sum(pd.boardings) as total_boardings, sum(pd.alightings) as total_alightings
  from route_stops as rs
  left join passenger_data pd on pd.stop_id = rs.stop_id
  group by rs.route_name
  order by rs.route_name
SQL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For reasons that will become clearer in a moment, I wrote a number of other queries, including these two:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;focused_query =&amp;lt;&amp;lt;SQL
  select rs.route_name, sum(pd.boardings) as total_boardings, sum(pd.alightings) as total_alightings
  from route_stops as rs
  left join passenger_data pd on pd.stop_id = rs.stop_id
  where rs.route_name in (146, 29, 2, &#39;X28&#39;, 4, 26)
  group by rs.route_name
  order by rs.route_name
SQL

map_query =&amp;lt;&amp;lt;SQL
  select rs.route_name, rs.stop_id,
  pd.boardings as total_boardings, pd.alightings as total_alightings,
  sl.loc_lat, sl.loc_long
  from route_stops as rs
  left join passenger_data pd on pd.stop_id = rs.stop_id
  left join stop_locations sl on sl.stop_id = rs.stop_id
  where rs.route_name in (146, 29, 2, &#39;X28&#39;, 4, 26)
SQL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s grab the results…&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;full_results   = CTA_BUSES.fetch(full_query).all
focused_routes = CTA_BUSES.fetch(focused_query).all
overlay_data   = CTA_BUSES.fetch(map_query).all
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and throw some results into an histogram using gnuplot!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Gnuplot.open do |gp|
  Gnuplot::Plot.new (gp) do |plot|
    plot.title &quot;Total Boardings and Alightings by Route, &#39;Entry Routes&#39;&quot;
    plot.style &quot;data histogram&quot;
    plot.xtics  &quot;nomirror rotate by -90&quot;
    #plot.xrange &quot;[0:160]&quot;

    routes     = entry_routes.map {|data| data[:route_name]}
    boardings  = entry_routes.map {|data| data[:total_boardings]}
    alightings = entry_routes.map {|data| data[:total_alightings]}

    plot.data &amp;lt;&amp;lt; Gnuplot::DataSet.new( [routes, boardings] )  {|ds| ds.title = &quot;Boardings&quot;;  ds.using = &#39;2:xtic(1)&#39;}
    plot.data &amp;lt;&amp;lt; Gnuplot::DataSet.new( [routes, alightings] ) {|ds| ds.title = &quot;Alightings&quot;; ds.using = &#39;2:xtic(1)&#39;}
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gives us…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/all_routes.png&quot; alt=&quot;All Routes&quot; title=&quot;All Routes&quot; style=&quot;max-width:100%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;…and…&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Gnuplot.open do |gp|
  Gnuplot::Plot.new (gp) do |plot|
    plot.title &quot;Total Boardings and Alightings by Route, Select Routes&quot;
    plot.style &quot;data histogram&quot;
    plot.xtics  &quot;nomirror rotate by -90&quot;

    routes     = focused_routes.map {|data| data[:route_name]}
    boardings  = focused_routes.map {|data| data[:total_boardings]}
    alightings = focused_routes.map {|data| data[:total_alightings]}

    plot.data &amp;lt;&amp;lt; Gnuplot::DataSet.new( [routes, boardings] )  {|ds| ds.title = &quot;Boardings&quot;;  ds.using = &#39;2:xtic(1)&#39;}
    plot.data &amp;lt;&amp;lt; Gnuplot::DataSet.new( [routes, alightings] ) {|ds| ds.title = &quot;Alightings&quot;; ds.using = &#39;2:xtic(1)&#39;}
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gives us…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/select_routes.png&quot; alt=&quot;Select Routes&quot; title=&quot;Select Routes&quot; style=&quot;max-width:100%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Lastly, we can also plot our data on a map!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;map_data = [&#39;146&#39;, &#39;29&#39;, &#39;2&#39;, &#39;X28&#39;, &#39;4&#39;, &#39;26&#39;].map { |selected_route|
  routes[selected_route] = overlay_data.
    select{|route| route[:route_name] == selected_route}.map { |route|
    {
     center: [route[:loc_lat], route[:loc_long]],
     boardings: route[:total_boardings].to_f,
     alightings: route[:total_alightings].to_f
    }
  }
}.to_json

File.open(&#39;./map.json&#39;,&#39;w&#39;){ |f| f.write map_data }

var busStop;

function initialize() {
  var mapOptions = {
    zoom: 12,
    center: new google.maps.LatLng(41.8500, -87.6500),
    mapTypeId: google.maps.MapTypeId.ROADMAP
  };
  var map = new google.maps.Map(document.getElementById(&#39;map-canvas&#39;),
      mapOptions);

  var colors = [&#39;#8dd3c7&#39;,&#39;#ffffb3&#39;,&#39;#bebada&#39;,&#39;#fb8072&#39;,&#39;#80b1d3&#39;,&#39;#fd8462&#39;];

  for (var i=0; i &amp;lt; bus_routes.length; i++){
    for (var j=0; j &amp;lt; bus_routes[i].length; j++){
      var stop = bus_routes[i][j];
      var passengerData = {
        strokeColor:colors[i],
        strokeOpacity: 0.8,
        strokeWeight: 2,
        fillColor: colors[i],
        fillOpacity: 0.35,
        map: map,
        center: new google.maps.LatLng(stop[&#39;center&#39;][0], stop[&#39;center&#39;][1]),
        radius: stop[&#39;boardings&#39;]
      };
      busStop = new google.maps.Circle(passengerData);
    }
  }
}

google.maps.event.addDomListener(window, &#39;load&#39;, initialize);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Giving us the lovely map shown below.&lt;/p&gt;

&lt;script src=&quot;https://maps.googleapis.com/maps/api/js?v=3.exp&amp;amp;sensor=false&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;/map.json&quot;&gt;&lt;/script&gt;

&lt;script&gt;
  var busStop;

  function initialize() {
    var mapOptions = {
      zoom: 12,
      center: new google.maps.LatLng(41.8500, -87.6500),
      mapTypeId: google.maps.MapTypeId.ROADMAP
    };
    var map = new google.maps.Map(document.getElementById(&#39;map-canvas&#39;),
        mapOptions);

    var colors = [&#39;#8dd3c7&#39;,&#39;#ffffb3&#39;,&#39;#bebada&#39;,&#39;#fb8072&#39;,&#39;#80b1d3&#39;,&#39;#fd8462&#39;];

    for (var i=0; i &lt; bus_routes.length; i++){
      for (var j=0; j &lt; bus_routes[i].length; j++){
        var stop = bus_routes[i][j];
        var passengerData = {
          strokeColor:colors[i],
          strokeOpacity: 0.8,
          strokeWeight: 2,
          fillColor: colors[i],
          fillOpacity: 0.35,
          map: map,
          center: new google.maps.LatLng(stop[&#39;center&#39;][0], stop[&#39;center&#39;][1]),
          radius: stop[&#39;boardings&#39;]
        };
        busStop = new google.maps.Circle(passengerData);
      }
    }
  }

  google.maps.event.addDomListener(window, &#39;load&#39;, initialize);

&lt;/script&gt;

&lt;div id=&quot;map-canvas&quot; style=&quot;height:400px&quot;&gt;&lt;/div&gt;

&lt;p&gt;Not the best visual analytics work, but I hope to have given a broad overview of what one needs to do in order to do something cool with data. Just spend 10x the amount of time/effort I put into this code to create something truly amazing!&lt;/p&gt;
</description>
        <pubDate>Tue, 02 Jul 2013 00:00:00 -0500</pubDate>
        <link>http://haiqus.com/data%20analysis/gnuplot/sequel/chicago%20transit%20authority/2013/07/02/fun-with-public-data/</link>
        <guid isPermaLink="true">http://haiqus.com/data%20analysis/gnuplot/sequel/chicago%20transit%20authority/2013/07/02/fun-with-public-data/</guid>
        
        
        <category>data analysis</category>
        
        <category>gnuplot</category>
        
        <category>sequel</category>
        
        <category>chicago transit authority</category>
        
      </item>
    
      <item>
        <title>A Better Fibonacci (Revisited)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://coderwall.com/p/_vou1q&quot;&gt;Previously&lt;/a&gt;, I posted a non-recursive algorithm to compute an arbitrary Fibonacci number:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHI = 1.6180339887498948482045868
const_fib = lambda do |n|
  (
    ( PHI**n - ( 1 - PHI )**n ) /
    Math.sqrt(5)
  ).
  floor
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the mathematical constant PHI is an infinite, non-repeating decimal, it can never be exactly represented in code. Indeed, the Fibonacci series computed by the above code and the exact series diverge after only the 70th value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;computed = []
(1..1474).each { |n| computed &amp;lt;&amp;lt; const_fib[n].to_s }

# list of Fibonnaci number can be downloaded from http://oeis.org/A000045/b000045.txt
exact = []
File.open(&#39;./exact.txt&#39;, &#39;r&#39;).each_line do |line|
  exact &amp;lt;&amp;lt; line.split.last
end

exact.shift # the first entry on the downloaded list is zero, get rid of it

index_of_last_match = (computed &amp;amp; exact).size
#=&amp;gt; 70

computed[index_of_last_match] == exact[index_of_last_match]
#=&amp;gt; true

computed[index_of_last_match + 1] == exact[index_of_last_match + 1]
#=&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When I first hacked at this hackneyed code exercise, I assumed using the constant PHI would still be more efficient than a loop or a recursive algorithm. Turns out, modern hardware make the loop-based solution quite tolerable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;loop_fib = lambda do |n|
  fib = []
  n.times do |n|
    if n &amp;lt; 2
      fib = [0, 1, 1]
    else
      fib &amp;lt;&amp;lt; ( fib[-1] + fib[-2] ).to_s
    end
  end
  return fib.last
end

loop_fib[70] == exact[70]
#=&amp;gt; true

loop_fib[71] == exact[71]
#=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My computer hardly notices. How about the recursive method?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;recur_fib = lambda do |n|
  case n
  when 0
    1
  when 1
    1
  else
    recur_fib[n - 1] + recur_fib[n - 2]
  end
end

recur_fib[70]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Beautiful math; horrifying code! Running it quickly ate up my memory and swap space.&lt;/p&gt;

&lt;p&gt;I’m going to pose a challenge for readers here. Read section 1.2.1 in &lt;a href=&quot;https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.1&quot;&gt;&lt;em&gt;Structure and Interpretation of Computer Programs&lt;/em&gt;&lt;/a&gt; for a much more reasonable recursive template, and try combining the approach in that book with the first algorithm above. Specifically, pack your recursion into a separate function that computes an arbitrary precision value for PHI. Can we get const_fib to run faster and more efficiently than loop_fib?&lt;/p&gt;
</description>
        <pubDate>Sat, 25 May 2013 00:00:00 -0500</pubDate>
        <link>http://haiqus.com/mathematics/recursion/sequences/2013/05/25/a-better-fibonacci-revisited/</link>
        <guid isPermaLink="true">http://haiqus.com/mathematics/recursion/sequences/2013/05/25/a-better-fibonacci-revisited/</guid>
        
        
        <category>mathematics</category>
        
        <category>recursion</category>
        
        <category>sequences</category>
        
      </item>
    
      <item>
        <title>Adjust Date Histogram Facet&#39;s Bin Position</title>
        <description>&lt;p&gt;ElasticSearch’s &lt;em&gt;Date Histogram&lt;/em&gt; is a nice built-in facet for binning data across a specified time interval.Using Tire (Ruby’s ElasticSearch wrapper), you can get a timeseries data thusly&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Tire.index(&#39;articles&#39;).search do
  facet &#39;words_per_month&#39; do
    date :created_at,
         :interval =&amp;gt; &quot;30d&quot;,
         :value_field =&amp;gt; :word_count
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The setting &lt;code&gt;:interval =&amp;gt; &quot;30d&quot;&lt;/code&gt; bins each document within a thirty day interval. ElasticSearch allows for bin widths from milliseconds to weeks; see the syntax in the documentation. Hence, if a document’s &lt;code&gt;created_at&lt;/code&gt; field is within a 30 day interval, the document will be placed in that bin and the specified &lt;code&gt;value_field&lt;/code&gt; will be passed on to statistical functions.&lt;/p&gt;

&lt;p&gt;This feature is pretty neat, but there’s one quirk in the way the kernel is placed for each bin. Let’s say you want to run statistics against documents relative to today’s date; you’ll have a problem, as the default kernel is set on the mid-month, eg. 04-14.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Tire.index(&#39;articles&#39;).search do
  facet &#39;words_per_month&#39; do
    date :created_at,
         :interval =&amp;gt; &quot;30d&quot;,
         :post_offset =&amp;gt; &quot;-13d&quot;,
         :value_field =&amp;gt; :word_count
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above will place your kernel at the start of the month by offsetting the default (eg, 04-14) to the default minus 13 days (04-01). But what we want is an offset of &lt;em&gt;n&lt;/em&gt; days where &lt;em&gt;n&lt;/em&gt; is the difference between the default and today’s date. Viola, in Ruby:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;n = (Time.now.day - 14).to_s
Tire.index(&#39;articles&#39;).search do
  facet &#39;words_per_month&#39; do
    date :created_at,
         :interval =&amp;gt; &quot;30d&quot;,
         :post_offset =&amp;gt; &quot;#{n}d&quot;,
         :value_field =&amp;gt; :word_count
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Try it!&lt;/p&gt;
</description>
        <pubDate>Tue, 21 May 2013 00:00:00 -0500</pubDate>
        <link>http://haiqus.com/elasticsearch/2013/05/21/adjust-date-histogram-facet-bin-position/</link>
        <guid isPermaLink="true">http://haiqus.com/elasticsearch/2013/05/21/adjust-date-histogram-facet-bin-position/</guid>
        
        
        <category>elasticsearch</category>
        
      </item>
    
  </channel>
</rss>
